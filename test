#include "hw2_test.h"
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>

using namespace std;

// ANSI color codes for terminal output
#define GREEN "\033[32m"
#define RED "\033[31m"
#define RESET "\033[0m"

// Test 1: Invalid arguments for set_sec (negative values)
bool testSetSecInvalidArguments() {
    errno = 0;
    long result = set_sec(-1, 1, 1);
    return result == -1 && errno == EINVAL;
}

// Test 2: Arguments > 1 normalized in set_sec
bool testSetSecNormalizeArguments() {
    errno = 0;
    long result = set_sec(2, 999, 3); // Should normalize to (1, 1, 1)
    if (result != 0) return false;
    return get_sec('s') == 1 && get_sec('m') == 1 && get_sec('c') == 1;
}

// Test 3: Non-root user calling set_sec
bool testSetSecNonRootUser() {
    errno = 0;

    if (geteuid() == 0) {
        // Running as root: set_sec should succeed
        long result = set_sec(1, 1, 1); // Root user trying to set clearance
        return result == 0;
    } else {
        // Running as non-root: set_sec should fail
        long result = set_sec(1, 1, 1); // Non-root user trying to set clearance
        return result == -1 && errno == EPERM;
    }
}
// Test 4: All zeros for set_sec
bool testSetSecAllZeros() {
    errno = 0;
    long result = set_sec(0, 0, 0); // Valid input
    if (result != 0) return false;
    return get_sec('s') == 0 && get_sec('m') == 0 && get_sec('c') == 0;
}

// Test 5: All ones for set_sec
bool testSetSecAllOnes() {
    errno = 0;
    long result = set_sec(1, 1, 1); // Valid input
    if (result != 0) return false;
    return get_sec('s') == 1 && get_sec('m') == 1 && get_sec('c') == 1;
}

// Test 6: Invalid `clr` value for get_sec
bool testGetSecInvalidArgument() {
    errno = 0;
    long result = get_sec('x'); // Invalid clearance character
    return result == -1 && errno == EINVAL;
}

// Test 7: Valid `clr` values for get_sec
bool testGetSecValidArguments() {
    errno = 0;
    set_sec(1, 1, 0); // Give sword and midnight clearances
    return get_sec('s') == 1 && get_sec('m') == 1 && get_sec('c') == 0;
}

// Test 8: Nonexistent PID for check_sec
bool testCheckSecNonexistentProcess() {
    errno = 0;
    long result = check_sec(-1, 'm'); // Invalid PID
    return result == -1 && errno == ESRCH;
}

// Test 9: Invalid clearance character in check_sec
bool testCheckSecInvalidClearance() {
    errno = 0;
    long result = check_sec(getpid(), 'z'); // Invalid clearance character
    return result == -1 && errno == EINVAL;
}

bool testCheckSecNoClearance() {
    errno = 0;

    // Step 1: Set no clearances for the current process
    if (set_sec(0, 0, 0) != 0) {
        cout << "testCheckSecNoClearance failed: Unable to set clearances to zero." << endl;
        return false;
    }

    // Step 2: Attempt to check "sword" clearance without having it
    long result = check_sec(getpid(), 's');
    if (result != -1) {
        cout << "testCheckSecNoClearance failed: check_sec did not return -1 as expected. Got: " << result << endl;
        return false;
    }

    // Step 3: Verify that errno is set to EPERM
    if (errno != EPERM) {
        cout << "testCheckSecNoClearance failed: errno is not EPERM. Got: " << errno << endl;
        return false;
    }

    // Test passed
    cout << "testCheckSecNoClearance passed." << endl;
    return true;
}


// Test 11: check_sec with sufficient clearance
bool testCheckSecWithClearance() {
    errno = 0;
    set_sec(1, 0, 0); // Give sword clearance
    long result = check_sec(getpid(), 's'); // Check sword clearance
    return result == 1;
}

// Test 12: Negative height for set_sec_branch
bool testSetSecBranchNegativeHeight() {
    errno = 0;
    long result = set_sec_branch(-1, 's'); // Invalid height
    return result == -1 && errno == EINVAL;
}

// Test 13: Height = 0 for set_sec_branch
bool testSetSecBranchHeightZero() {
    errno = 0;
    long result = set_sec_branch(0, 'm'); // Invalid height
    return result == -1 && errno == EINVAL;
}

// Test 14: Valid set_sec_branch with height > ancestry depth
bool testSetSecBranchExceedHeight() {
    set_sec(0, 1, 0); // Give midnight clearance
    long result = set_sec_branch(100, 'm'); // Excessive height
    return result >= 1; // Should update at least one parent
}

// Test 15: Clearance inheritance on fork
bool testClearanceInheritanceOnFork() {
    set_sec(1, 0, 0); // Give sword clearance
    pid_t child_pid = fork();
    if (child_pid == 0) {
        exit(get_sec('s') == 1 ? 0 : 1);
    }
    int status;
    waitpid(child_pid, &status, 0);
    return WIFEXITED(status) && WEXITSTATUS(status) == 0;
}

// Test 16: Clearance propagation with set_sec_branch
bool testSetSecBranchPropagation() {
    pid_t child_pid = fork();
    if (child_pid == 0) {
        pid_t grandchild_pid = fork();
        if (grandchild_pid == 0) {
            set_sec(0, 1, 0); // Midnight clearance
            long result = set_sec_branch(1, 'm'); // Propagate midnight clearance
            exit(result == 1 ? 0 : 1);
        }
        waitpid(grandchild_pid, nullptr, 0);
        exit(get_sec('m') == 1 ? 0 : 1);
    }
    waitpid(child_pid, nullptr, 0);
    return get_sec('m') == 0; // Parent should not gain clearance
}

// Test 17: Boundary case for set_sec
bool testSetSecBoundaryValues() {
    long result = set_sec(0, 1, 1); // Valid input
    return result == 0;
}

// Test 18: Concurrent set_sec calls
bool testConcurrentSetSec() {
    set_sec(0, 0, 0); // No clearance initially
    pid_t pids[2];
    for (int i = 0; i < 2; ++i) {
        pids[i] = fork();
        if (pids[i] == 0) {
            set_sec(1, 0, 0); // Give sword clearance
            exit(get_sec('s') == 1 ? 0 : 1);
        }
    }
    for (int i = 0; i < 2; ++i) {
        int status;
        waitpid(pids[i], &status, 0);
        if (!(WIFEXITED(status) && WEXITSTATUS(status) == 0)) {
            return false;
        }
    }
    return true;
}

// Test 19: Invalid clearance value for set_sec_branch
bool testSetSecBranchInvalidClearance() {
    errno = 0;
    long result = set_sec_branch(1, 'z'); // Invalid clearance
    return result == -1 && errno == EINVAL;
}

// Test 20: Check default clearance for init process
bool testDefaultInitClearance() {
    pid_t init_pid = 1; // PID 1 is usually the init process
    errno = 0;

    // Step 1: Ensure the calling process does not have the required clearance
    if (set_sec(0, 0, 0) != 0) {
        cout << "testDefaultInitClearance failed: Unable to clear all clearances for the calling process." << endl;
        return false;
    }

    // Attempt to check the clearance of the init process without having the required clearances
    if (check_sec(init_pid, 's') != -1 || errno != EPERM) {
        cout << "testDefaultInitClearance failed: check_sec did not fail as expected when calling process lacks clearance (sword)." << endl;
        return false;
    }
    if (check_sec(init_pid, 'm') != -1 || errno != EPERM) {
        cout << "testDefaultInitClearance failed: check_sec did not fail as expected when calling process lacks clearance (midnight)." << endl;
        return false;
    }
    if (check_sec(init_pid, 'c') != -1 || errno != EPERM) {
        cout << "testDefaultInitClearance failed: check_sec did not fail as expected when calling process lacks clearance (clamp)." << endl;
        return false;
    }

    // Step 2: Grant all clearances to the calling process
    if (set_sec(1, 1, 1) != 0) {
        cout << "testDefaultInitClearance failed: Unable to grant all clearances to the calling process." << endl;
        return false;
    }

    // Step 3: Validate that the init process does not have any clearances
    if (check_sec(init_pid, 's') != 0) {
        cout << "testDefaultInitClearance failed: Unexpected sword clearance for init process." << endl;
        return false;
    }
    if (check_sec(init_pid, 'm') != 0) {
        cout << "testDefaultInitClearance failed: Unexpected midnight clearance for init process." << endl;
        return false;
    }
    if (check_sec(init_pid, 'c') != 0) {
        cout << "testDefaultInitClearance failed: Unexpected clamp clearance for init process." << endl;
        return false;
    }

    cout << "testDefaultInitClearance passed." << endl;
    return true;
}

int main() {
    int passedTests = 0;
    int totalTests = 20;

    cout << "Running tests..." << endl;

    // List of all tests
    auto tests = {
            testDefaultInitClearance,testCheckSecNoClearance,testSetSecInvalidArguments, testSetSecNormalizeArguments, testSetSecNonRootUser,
            testSetSecAllZeros, testSetSecAllOnes, testGetSecInvalidArgument,
            testGetSecValidArguments, testCheckSecNonexistentProcess,
            testCheckSecInvalidClearance,
            testCheckSecWithClearance, testSetSecBranchNegativeHeight,
            testSetSecBranchHeightZero, testSetSecBranchExceedHeight,
            testClearanceInheritanceOnFork, testSetSecBranchPropagation,
            testSetSecBoundaryValues, testConcurrentSetSec,
            testSetSecBranchInvalidClearance
    };
    int i=1;
    // Run each test and log results
    for (auto test : tests) {
        if (test()) {
            cout << GREEN << i << " PASS" << RESET << endl;
            passedTests++;
        } else {
            cout << RED << i << " FAIL" << RESET << endl;
        }
        i++;
    }

    cout << "\nTests Passed: " << GREEN << passedTests << RESET << "/" << totalTests << endl;

    return 0;
}
